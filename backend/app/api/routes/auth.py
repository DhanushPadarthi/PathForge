from fastapi import APIRouter, HTTPException, status, Depends\nfrom datetime import datetime\nimport uuid\n\nfrom ...config.mongodb import db\nfrom ...core.security import get_password_hash, verify_password, create_access_token\nfrom ...core.dependencies import get_current_active_user\nfrom ...schemas.user_schema import (\n    UserSignupRequest,\n    UserLoginRequest,\n    TokenResponse,\n    UserResponse\n)\n\nrouter = APIRouter()\n\n@router.post(\"/signup\", response_model=TokenResponse, status_code=status.HTTP_201_CREATED)\nasync def signup(user_data: UserSignupRequest):\n    \"\"\"\n    Register a new user\n    \"\"\"\n    users_collection = db.get_collection(\"users\")\n    \n    # Check if user already exists\n    existing_user = await users_collection.find_one({\"email\": user_data.email})\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    user_id = str(uuid.uuid4())\n    new_user = {\n        \"_id\": user_id,\n        \"email\": user_data.email,\n        \"password_hash\": get_password_hash(user_data.password),\n        \"name\": user_data.name,\n        \"role\": \"user\",\n        \"is_active\": True,\n        \"has_resume\": False,\n        \"resume_url\": None,\n        \"extracted_skills\": [],\n        \"career_role_id\": None,\n        \"learning_time\": None,\n        \"deadline\": None,\n        \"created_at\": datetime.utcnow(),\n        \"updated_at\": datetime.utcnow(),\n        \"last_login\": datetime.utcnow()\n    }\n    \n    await users_collection.insert_one(new_user)\n    \n    # Generate access token\n    access_token = create_access_token(data={\"sub\": user_id})\n    \n    # Remove password_hash before returning\n    del new_user[\"password_hash\"]\n    \n    return TokenResponse(\n        access_token=access_token,\n        token_type=\"bearer\",\n        user=UserResponse(**new_user)\n    )\n\n@router.post(\"/login\", response_model=TokenResponse)\nasync def login(credentials: UserLoginRequest):\n    \"\"\"\n    Login user with email and password\n    \"\"\"\n    users_collection = db.get_collection(\"users\")\n    \n    # Find user by email\n    user = await users_collection.find_one({\"email\": credentials.email})\n    \n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid email or password\"\n        )\n    \n    # Verify password\n    if not verify_password(credentials.password, user[\"password_hash\"]):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid email or password\"\n        )\n    \n    # Check if user is active\n    if not user.get(\"is_active\", True):\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Account is inactive\"\n        )\n    \n    # Update last login\n    await users_collection.update_one(\n        {\"_id\": user[\"_id\"]},\n        {\"$set\": {\"last_login\": datetime.utcnow()}}\n    )\n    \n    # Generate access token\n    access_token = create_access_token(data={\"sub\": user[\"_id\"]})\n    \n    # Remove password_hash before returning\n    del user[\"password_hash\"]\n    \n    return TokenResponse(\n        access_token=access_token,\n        token_type=\"bearer\",\n        user=UserResponse(**user)\n    )\n\n@router.get(\"/me\", response_model=UserResponse)\nasync def get_current_user_info(current_user: dict = Depends(get_current_active_user)):\n    \"\"\"\n    Get current authenticated user information\n    \"\"\"\n    # Remove password_hash\n    if \"password_hash\" in current_user:\n        del current_user[\"password_hash\"]\n    \n    return UserResponse(**current_user)\n\n@router.post(\"/logout\")\nasync def logout(current_user: dict = Depends(get_current_active_user)):\n    \"\"\"\n    Logout user (client should remove token)\n    \"\"\"\n    return {\"message\": \"Logged out successfully\"}
